#!/usr/bin/perl

# apt-repo -- Manipulate APT repository list
# $Id: apt-repo,v 1.2.0 2013-11-07 12:41:00 cas Exp $

# Copyright 2011-2013 by Andrey Cherepanov (cas@altlinux.org)
# Copyright 2015 by Ivan Zakharyaschev (imz@altlinux.org)
# (imz: support for relying on apt-config and APT_CONFIG)
# (imz: Support for local --hsh-apt-config=FILE together with hasher.)

# This program is free software; you can redistribute it and/or modify it
# under the terms of GNU General Public License (GPL) version 3 or later.

use strict;
use warnings;

# Default parameters
our $VERSION = '1.2.2';

my $type     = 'rpm';
my $c_branch = 'classic';
my $c_task   = 'task';
my $noarch   = 'noarch';

my $cmd      = 'list';
my $continues = 0;
my $hsh = 0;
if ( scalar @ARGV > 0 and $ARGV[0] =~ /^--hsh-apt-config=(.*)$/ ) {
    # Printing is useful for debugging, too:
    print STDERR "Info: Will use hasher when appropriate (with --apt-config=$1).\n";
    $ENV{APT_CONFIG} = $1;
    $hsh = 1;
    shift;
}
$cmd = $ARGV[0] if scalar @ARGV > 0;

# Get system arch
my $arch = `/bin/uname -m`;
chomp $arch; # Truncate carriage return from output
# arch for x86_32
$arch = 'i586' if $arch =~ /^i686$/;

# Default repository paths
my $repo_base = 'http://ftp.altlinux.org/pub/distributions/ALTLinux/';
my $repo_task = 'http://git.altlinux.org/repo/';
my $conf_main = '/etc/apt/sources.list';
my $conf_list = '/etc/apt/sources.list.d/*.list';
if ( defined $ENV{APT_CONFIG} ) {
    # The following expression is intentionally crazily complex,
    # because we want to debug how children see the environment variable.
    print STDERR 'Info: will try to read a non-system APT_CONFIG=' . `echo -nE "\$APT_CONFIG"` . "\n";
    if ( $ENV{APT_CONFIG} =~ /^~/ ) {
	print STDERR 'Warning: your APT_CONFIG begins with ~, but no tilde expansion will take place!' . "\n";
    }
}
# If APT is missing in the system, we fallback to the common defaults above.
# Otherwise, we get the paths from APT itself:
# (if `apt-config` is missing, the pattern below won't match.)
if ( `apt-config shell FILE Dir::Etc::sourcelist/f` =~ /^FILE=(.*)$/ ) {
    # We are lucky that `apt-config` has the /f and /d "switches" which
    # make it resolve the configuration parameters into "normalized"
    # full paths to files and dirs.

    # $1 is a string quoted for the shell (with quotation marks around it).
    # Therefore we rely on shell itself to print it cleanly:
    $conf_main = `echo -nE $1`;
    # Invalidate the default because we want consistent values from `apt-config`: 
    $conf_list = '';
    if ( `apt-config shell DIR Dir::Etc::sourceparts/d` =~ /^DIR=(.*)$/ ) {
	$conf_list = `echo -nE $1` . "*.list";
    } else {
	print STDERR "Warning: Getting Dir::Etc::sourceparts/d from `apt-config` went wrong; falling back to '$conf_list' instead.\n"
    }
} else {
    print STDERR "Warning: Getting Dir::Etc::sourcelist/f from `apt-config` went wrong; falling back to '$conf_main' instead.\n"
}
my %repo_keys = ( 
	'Sisyphus' => 'alt' );
my @branches  = (
	'4.0',
	'4.1',
	'5.0',
	'p5',
	'5.1',
	'c6',
	'p6',
	't6',
	'p7',
	't7',
	'c7',
	'sisyphus',
	'Sisyphus'
);
my $default_key = 'updates';

# Show usage information
sub show_usage {
	print <<"HELP";
Usage: apt-repo [--hsh-apt-config=FILE] COMMAND SOURCE
Manipulate APT repository list.

COMMANDS:
  list [-a]        List active or all repositories
  list [task] <id> List task packages
  add <source>     Add APT repository
  rm <source|all>  Remove APT repository
  clean            Remove all cdrom and task sources
  update           Update APT caches
                   (Runs `hsh --initroot-only` if `--hsh-apt-config` is given.)
  test [task] <id> Install all packages (except *-debuginfo) from task
                   (Uses hasher(7) if `--hsh-apt-config` is given.)
  -h, --help       Show help and exit
  -v               Show version and exit

<source> may be branch or task name, sources.list(5) string, URL or local path.

The files to be manipulated are determined by a call to apt-config(8).
Consequently, APT_CONFIG environment variable can be used to point
to arbitrary non-system configurations for APT.

There is a switch for the special case when you want to use hasher(7) together
with a local APT configuration: --hsh-apt-config=FILE.
Note that no tilde expansion is performed on FILE!
HELP
	exit 0;
}

# Show version
sub show_version {
	print "$VERSION\n";
	exit 0;
}

# Return list of repositories as text
sub get_repos {
	my $all = shift;
	my @out = ();
	my $output;

	# Show all active repositories
	open P, '-|', "egrep -h '^[[:space:]]*$type(-src|-dir)?[[:space:]]+'  $conf_main $conf_list";
	@out = <P>;
	close P;
	$output = join( "", @out );

	# On -a show all available commented repositories
	if( defined $all and $all =~ /^-a$/ ) {
		open P, '-|', "egrep -h '^[[:space:]]*#[[:space:]]*$type(-src|-dir)? '  $conf_main $conf_list";
		@out = <P>;
		close P;
		$output .= join( "", @out );
	}

	return $output;
}

# Get package list for task
sub get_task_content {
	my $task = shift;
	my @out = ();

	die "Missing or wrong task number" if ! defined $task or ! $task=~ /^(\d+)$/;

	open P, '-|', "curl -s http://git.altlinux.org/tasks/$task/plan/add-bin | cut -f1 | grep -v '\\-debuginfo\$' | sort ";
	@out = <P>;
	close P;
	return @out;
}

# Show repositories
sub show_repo {
	shift;
	my $all = shift;

	# List for task packages by task number or canonical form `task <number>`
	if( defined $all and $all =~ /^(\d+|task)$/ ) {
		$all = shift if $all =~ /^task$/;
		print join( "",get_task_content( $all ) );
	} else {
		print get_repos( $all );
	}

	exit 0;
}

# Determine repository URL
sub get_url {
	my $repo   = shift;
	my $object = shift;
	my @url    = @_;
	my $u;
	my @branch_source;

	defined $repo or die "Unknown source. See `man apt-repo` for details.";

	# Quick forms: known branch name or number for task
	if( grep( /^\Q$repo\E$/, @branches ) ) {
		$object = $repo;		
		$repo = 'branch';
	}

	if( $repo =~ /^[0-9]+$/ ) {
		$object = $repo;		
		$repo = 'task';
	}

	# Branch 	
	if( $repo =~ /^branch$/ ) {
		if ( not defined $object )  {
			# Show all available branch names
			foreach( @branches ) {
				print $_ . "\n";
			}
			exit 0;
		}
		my $key = $object;

		# Fix Sisyphus name
		$object = 'Sisyphus' if $object =~ /^sisyphus$/;

		# Fix keys
		if( exists( $repo_keys{ $object } ) ) {
			$key = $repo_keys{ $object };
		} else {
			$key = $default_key;
		}

		if( $object =~ /^Sisyphus$/ ) {
			# Sisyphus
			$u = 'rpm [' . $key . '] ' . $repo_base . $object;
		} else {
			$u = 'rpm [' . $key . '] ' . $repo_base . $object . '/branch';
		}

		@branch_source = (
			$u . ' ' . $arch . ' ' . $c_branch,
			$u . ' ' . $noarch . ' ' . $c_branch
		);
		# For x86_64 add Arepo 2.0 source
		if( $arch =~ /^x86_64$/ ) {
			push( @branch_source, $u . ' x86_64-i586 ' . $c_branch);
		}

		return @branch_source;

	}

	# Task
	if( $repo =~ /^task$/ ) {
		if( not defined $object ) {
			print "Task number is missed.\n";
			exit 1;
		}
		if( $arch =~ /^x86_64$/ ) {
			# Arepo source for x86_64
			return (
				'rpm ' . $repo_task . $object . '/ ' . $arch . ' ' . $c_task,
				'rpm ' . $repo_task . $object . '/ x86_64-i586 ' . $c_task
			);
		} else {
			return ( 'rpm ' . $repo_task . $object . '/ ' . $arch . ' ' . $c_task );
		}
	}

	# URL
	if( $repo =~ /^(http|ftp|rsync|file|copy|cdrom):\// ) {
		my $u = 'rpm ' . $repo;
		my $component = $c_branch;

		if( defined $object ) {
			# Architecture is defined
			return ( $u . ' ' . $object . ' ' . join( ' ', @url ) );
		} else {
			# Mirror
			return (
				$u . ' ' . $arch . ' ' . $component, 
				$u . ' ' . $noarch . ' ' . $component
			);
		}
	}

	# Absolute path for hasher repository
	if( $repo =~ /^\// ) {
		return ( 'rpm file://' . $repo . ' ' . $arch . ' hasher' );
	}

	# In format of sources.list(5)
	if( $repo =~ /^$type(-src|-dir)?\b/ ) {
		if( defined $object ) {
			return ( $repo . ' ' . $object . ' ' . join( ' ', @url ) );
		} else {
			return ( $repo );
		}
	}

	return ();
}

# Add repository to list
sub add_repo {
	shift;
	my $repo   = shift;
	my $object = shift;
	my @comps  = @_;
	my $a_found;
	my $i_found;

	my @urls = get_url( $repo, $object, @comps );

	if( scalar @urls == 0 ) {
		print "Nothing to add: bad source format. See `man apt-repo` for details.\n";
		exit 1;
	}

	foreach my $u ( @urls ) {
		$a_found = 0;
		$i_found = 0;

		#print "added $u\n";

		# Lookup active ones
		foreach( split( /\n/, get_repos( '-a' ) ) ) {
			# Check active ones
			if( /^\Q$u\E$/ ) {
				# This source is active 
				$a_found = 1;
				last;
			}
			# Check commented ones
			if( /^[[:space:]]*#[[:space:]]*\Q$u\E$/ ) {
				# This source is existing and commented
				$i_found = 1;
				last;
			}
		}

		#print "$a_found $i_found $u\n";

		# Process source
		next if $a_found; # Source is active, nothing do

		# Uncomment commented source
		if( $i_found ) {
			my $ur = quotemeta $u;
			# Unescape parenthesis in sources for correct sed work
			$ur =~ s/\\\(/(/;
			$ur =~ s/\\\)/)/;
			system "sed -i 's/^[[:space:]]*#[[:space:]]*\\($ur\\)\$/\\1/' $conf_main $conf_list";
			next;
		}

		# Append to main sources list file
		open CONFIG, '>>', "$conf_main" or die "Can't open $conf_main: $!";
		print CONFIG $u . "\n";
		close CONFIG;

	}

	exit 0 if ! $continues;
}

# Remove repository from list
sub rm_repo {
	shift;
	my $repo   = shift;
	my $object = shift;
	my @comps  = @_;
	my $a_found;
	my $i_found;

	my @urls;

	if( defined $repo and $repo =~ /^all$/ ) {
		# Remove all active sources
		open P, '-|', "egrep -h '^[[:space:]]*$type(-src|-dir)?[[:space:]]+'  $conf_main $conf_list";
		@urls = <P>;
		close P;

		# Remove repositories by specified type
		if( defined $object ) {
			$object =~ /^(branch|branches|task|tasks|cdrom|cdroms)$/ or die "Missing repository type for `apt-repo rm all <type>`";
			@urls = grep( /\b\Q$repo_base\E/, @urls ) if( $object =~ /^branch(es)?$/ );
			@urls = grep( /\b\Q$repo_task\E[0-9]+/, @urls ) if( $object =~ /^task(s)?$/ );
			@urls = grep( /^[[:space:]]*rpm[[:space:]]+cdrom:/, @urls ) if( $object =~ /^cdrom(s)?$/ );
		}

	} else {
		@urls = get_url( $repo, $object, @comps );
	}

	my $has_warning = 0;
	foreach my $u ( @urls ) {
		$a_found = 0;
		$i_found = 0;

		chomp $u;

		# Lookup active
		foreach( split( /\n/, get_repos() ) ) {
			# Check active
			if( /^\Q$u\E$/ ) {
				# This source is active 
				$a_found = 1;
				last;
			}
		}

		#print "$a_found $u\n";

		# Remove from $conf_main, comment in other files
		if( $a_found ) {
			$u = quotemeta $u;
			# Unescape parenthesis in sources for correct sed work
			$u =~ s/\\\(/(/;
			$u =~ s/\\\)/)/;
			system "sed -i -e '/^[[:space:]]*$u\$/d' $conf_main";
			system "sed -i 's/^[[:space:]]*$u\$/#$u/' $conf_list";
		} else {
			if( not $has_warning ) {
				print "Nothing to remove: source was not found.\n";
				$has_warning = 1;
			}
		}
	}
	return 0;
}

# Remove all cdrom and task repositories
sub clear_repo {
	my @cmd;

	@cmd = qw(rm all cdroms);
	rm_repo( @cmd );

	@cmd = qw(rm all tasks);
	rm_repo( @cmd );

	exit 0 if ! $continues;
}

# Update repo
sub update_repo {
    if (! $hsh ) {
	system 'apt-get update';
    } else {
	system "hsh --apt-config=\"\$APT_CONFIG\" --initroot-only";
    }
	exit 0 if ! $continues;
}

# Test task
sub test_task {
	shift;
	my $task = shift;
	my @pkgs = ();
	my $list = "";

	$task = shift if $task =~ /^task$/;
	@pkgs = get_task_content( $task );

	# Add source and update indices
	$continues = 1;
	add_repo( ("add", "task", $task ) );
	update_repo();

	# Install all packages from task (except *-debuginfo)
	chomp( @pkgs );
	$list = join( " ", @pkgs );

	# Install packages from task repository
	if (! $hsh ) {
	    system "apt-get install $list";
	} else {
	    system "hsh-install $list";
	}

	# Remove task source
	rm_repo( ("rm", "task", $task ) );

	exit 0;
}

# Process command line arguments

# Exiting functions
show_repo( @ARGV ) if $cmd =~ /^list$/;
show_repo( 'list', '-a' ) if $cmd =~ /^-a$/;
show_usage() if $cmd =~ /-(h|-help)$/ or scalar @ARGV == 0; 
show_version() if $cmd =~ /-(v|-version)$/;
clear_repo( @ARGV ) if $cmd =~ /^clea[rn]$/;
update_repo() if $cmd =~ /^update$/;
test_task( @ARGV ) if $cmd =~ /^test$/;

# Functions with return
if( $cmd =~ /^(add|rm)$/ ) {
	add_repo( @ARGV ) if $cmd =~ /^add$/;
	rm_repo( @ARGV ) if $cmd =~ /^rm$/;
} else {
	print "Unknown command `$cmd`.\nRun `apt-repo --help` for supported commands.\n";
	exit 1;
}

__END__
